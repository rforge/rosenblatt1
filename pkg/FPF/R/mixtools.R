# TODO: Add comment
# 
# Author: johnros
###############################################################################




#
##' Map mixtools output to simple vector
##' @param mixedtools.output Output of \code{\link{normalmixEM}}. List of class \emph{mixEM}.  
##' @param result The vector to be returned with \code{\link{normalmixEM}} output
##' @param model Character vector specifying the type of model fitted with \code{\link{normalmixEM}}. 
##' @return Vector of voxel-wise parameter estimates.
##' Utility function for \code{\link{pointWiseMixtureFit}}
##' @author Jonathan Rosenblatt 
##' @export
mixedtools2result<- function(mixedtools.output, result, model){
	
	# Preparing output for **full** model:
	if(model=="full"){
		component.order<- c( order(mixedtools.output$sigma[c(1,2)]) , 3)
		result[c("p1.1","p2.1","p3.1")] <- mixedtools.output$lambda[component.order] 
		result[c("A.1","B.1","C.1")] <- mixedtools.output$sigma[component.order]^2
		result["mu.1"]<- mixedtools.output$mu[component.order][3]				
	}
	
	
	
	# Preparing output for **null** model:
	if(model=="null"){
		component.order<- order(mixedtools.output$sigma[c(1,2)]) 
		result[c("p1.0","p2.0")] <- mixedtools.output$lambda[component.order] 
		result[c("A.0","B.0")] <- mixedtools.output$sigma[component.order]^2	
	}
	
	return(result)
}















#
##' Pointwise fitting of group mixture
##' @param beta.vector Numeric vector of estimated contrasts. One per subject.
##' @param fit.control List of control parameters generated by \code{\link{generateMixtureControl}} 
##' @param progress A connection object to a progress bar. 
##' @return Numeric vector with estimates of mixture parameters.
##' 
##' @author Jonathan Rosenblatt 
##' @export
pointWiseMixtureFit<- function(beta.vector, fit.control, progress){
	require(mixtools)
	# Verify intput:
	stopifnot(is.numeric(beta.vector))
	
	
	# Initialize output:
	if(!missing(progress)) { setTxtProgressBar(progress, getTxtProgressBar(progress)+1)	}
	
	output<- initializeOutput()
	n<- sum(!is.na(beta.vector))
	output[['n']]<- n
	if(n < fit.control$minObservations) return(output)
	clean.beta.vector<- na.omit(beta.vector)
	
	
	
	try({
				capture.output(temp.result.three.components <- pointWise3MixtureFit(clean.beta.vector, fit.control))
				output<- mixedtools2result(temp.result.three.components, output, model="full")
				
				
				p3.bound<- p3Bound(mu=output[['mu.1']], A=output[['A.1']], B=output[['B.1']], n=output[['n']], fit.control=fit.control)
				output[['p3.bound']]<- p3.bound
				
				if(output[['p3.1']] > p3.bound) {
					# Note: present implementation forces constraint. Next- optimize with it.
					# TODO: B) Imlpement constrained optimization
					output[['p3.1']]<- p3.bound
				} 
				
				
				
				
				# Fit 2 component mixture
				capture.output(temp.result.two.components<- pointWise2MixtureFit(clean.beta.vector, fit.control, temp.result.three.components))
				output<- mixedtools2result(temp.result.two.components, output, model="null")
				
			}) # End of "try" statement
	
	
	
	
	# Finiliazing:
	return(output)
}
## Testing:
#.data<- scans[30,20,30,]
#(output<- pointWiseMixtureFit(.data, fit.control = generateMixtureControl()))











#
##' Voxelwise fit of *three* component mixture
##' @param beta.vector Nuemric (cleaned) vector of beta estimates.
##' @param fit.control 
##' @return An \link{mixEM} class object of the three component mixture fit.
##' 
##' @author Jonathan Rosenblatt 
##' @examples 
##'.data<- na.omit(scans[20,20,20,])
##'(output.3<- pointWise3MixtureFit(.data, fit.control= generateMixtureControl()))
pointWise3MixtureFit<- function(beta.vector, fit.control){
	
	temp.result<- normalmixEM(beta.vector, k=3, mean.constr = c(0,0,NA), verb=FALSE )
	
	return(temp.result)
	
}
## Testing:
#.data<- na.omit(scans[20,20,20,])
#output.3<- pointWise3MixtureFit(.data, fit.control= generateMixtureControl())
#sum(output.3$lambda)
















##' #' Voxelwise fit of *two* component mixture
##' @param beta.vector Nuemric (cleaned) vector of beta estimates
##' @param fit.control 
##' @param three.component.fit Output of \link{pointWise3MixtureFit} as initialization.
##' @return  An \link{mixEM} class object of the two component mixture fit.
##' 
##' @author Jonathan Rosenblatt 
##' @examples 
##'.data<- na.omit(scans[20,20,20,])
##'output.3<- pointWise3MixtureFit(.data, fit.control= generateMixtureControl())
##'(output.2<- pointWise2MixtureFit(.data, fit.control= generateMixtureControl(), three.component.fit = output.3))
pointWise2MixtureFit<- function(beta.vector, fit.control, three.component.fit){
	renormalize.lambda<- three.component.fit$lambda[c(1,2)] / sum(three.component.fit$lambda[c(1,2)])
	temp.result<- normalmixEM(beta.vector, k=2, mean.constr = c(0,0), verb=FALSE, lambda=renormalize.lambda , mu=c(0,0), sigma=three.component.fit$sigma[c(1,2)] )
	
	return(temp.result)
	
}
## Testing:
#.data<- na.omit(scans[20,20,20,])
#output.3<- pointWise3MixtureFit(.data, fit.control= generateMixtureControl())
#(output.2<- pointWise2MixtureFit(.data, fit.control= generateMixtureControl(), three.component.fit = output.3))











##' Fits a mixture models to a group SPM{beta}
##' @param MRImage.list  List of Mriimage objects. All assumed to have same resolution and representing different subjects.
##' @param fit.control List of control parameters generated by \code{\link{generateMixtureControl}} 
##' @param ... Deprecated
##' @return List of MriImage objects. Each holding the SPM of a different parameters:
##' \item{initial.p1}{Deprecated}
##' \item{initial.p2}{Deprecated}
##' \item{initial.p3}{Deprecated}
##' \item{initial.mu}{Deprecated}
##' \item{initial.A}{Deprecated}
##' \item{initial.B}{Deprecated}
##' \item{initial.C}{Deprecated}
##' \item{p1.1}{Estimate of \emph{full} mixture parameters.}
##' \item{p2.1}{Estimate of \emph{full} mixture parameters.}
##' \item{p3.1}{Estimate of \emph{full} mixture parameters.}
##' \item{mu.1}{Estimate of \emph{full} mixture parameters.}
##' \item{A.1}{Estimate of \emph{full} mixture parameters.}
##' \item{B.1}{Estimate of \emph{full} mixture parameters.}
##' \item{C.1}{Estimate of \emph{full} mixture parameters.}
##' \item{likelihood.1}{\emph{Full} maximal likelihood.}
##' \item{p3.bound}{Maximal allowed value for p.3 given other parameter estimates. Serves to check if parameter space constraints are violated.}
##' \item{p1.0}{Estimate of \emph{null} mixture parameters.}
##' \item{p2.0}{Estimate of \emph{null} mixture parameters.}
##' \item{A.0}{Estimate of \emph{null} mixture parameters.}
##' \item{B.0}{Estimate of \emph{null} mixture parameters.}
##' \item{likelihood.0}{\emph{Null} maximal likelihood}
##' \item{n}{Sample size.}
##'     
##' Given a list of MriImage objects-- all registered to a common template--   the function will fit a mixture model at each voxel and return an array of the voxel-wise parameter estimates.
##' The fitting is done using the \link{mixtools}  package.
##' The mixture being fitted is parametrized as: \deqn{p_1 \phi_{0,\sigma_1}+p_2 \phi_{0,\sigma_2}+p_3 \phi_{\mu,\sigma_3}   } where
##' \eqn{\phi_{\mu,\sigma}} is the Gaussian PDF.
##'  
##' @author Jonathan Rosenblatt 
##' @references Revisiting Multi-Subject Random Effects in fMRI
##' Rosenblatt J.D., Vink M., Benjamini Y. (2012) 
##' @examples 
##' data(VinkData)
##' ### No need to run. Output already in VinkDataFit in order to save time.
##' #test.brain.fit<- brainMixtureFit(scans, fit.control = generateMixtureControl())
##' data(VinkDataFit)
##' createSliceGraphic(test.brain.fit[["p3.1"]], z=26)
##' image(test.brain.fit[["p3.1"]]$getData()[,,26])
##' lapply(test.brain.fit, function(x) x$getData()[20,20,20])
##' @export
brainMixtureFit2<- function(MRImage.list, fit.control= generateMixtureControl()){
	
	## Verify input:
	stopifnot(is.list(MRImage.list) && class(MRImage.list[[1]])=="MriImage" ) 
	
	
	
	## Initialize:
	#Arranging data in one array:
	beta.array<- MriImage2Array(MRImage.list)
	
	# For debugging:	beta.array<- beta.array[25:30,28:30,28:30,]
	
	dims<-dim(beta.array)
	cat('This may take several minutes. Why not load the fortunes package and enjoy those quotes?\n')
	log.file.name<- tempfile("Mixture_Log_")
	log.con<- file(log.file.name, open="wt")
	sink(file=log.con, type="message")
	cat("Log written to", log.file.name,"\n")	
	progress.bar<- txtProgressBar(min=0, max=prod(dims[-4]), style=1)
	warn <- options(warn = 2)
	
	
	
	
	
	
	## Fit- first step
	pointwise<- function(beta.vector) {
		unlist(pointWiseMixtureFit(beta.vector = beta.vector, fit.control = fit.control, progress=progress.bar))
	}
	
	
	first.fit <- apply(beta.array, c(1,2,3), pointwise)
	close(progress.bar)
	
	
	
	
	
	# TODO: C) Add imputation and smoothing before re-estimation + check which solution has highest likelihood
	
	## Smooth estimates:
	# impute array before smoothing
	# smooth estimates	
	smoothed.fit<- first.fit	
	
	
	
	## Second fit:
	second.fit<- smoothed.fit
	
	
	
	
	## Impute non-convergence
	imputed.fit<-  wrapImputeArray(second.fit)
	
	
	
	
	## Finilizing
	dim.names<- dimnames(first.fit)
	fitted.list<- list()
	meta<- newMriImageMetadataFromTemplate(MRImage.list[[1]]$getMetadata(), datatype=getDataTypeByNiftiCode(16))
	for(param in dim.names[[1]]){
		fitted.list[[param]]<- newMriImageWithData(imputed.fit[param,,,], meta)
	}
	
	
	
	## Exit:
	options(warn)
	sink(type="message")
	message('Done')
	return(fitted.list)
	
	
}
## Testing:
#require(tractor.base)
#setwd('~/Projects/MRI/Data/Vink/data_vink_2010/cons_no_smooth')
#(files<- grep("con.*img", list.files(), value=T))
#(files<- sub('\\.img', "", files))
#scans<- importBetaMriImages(files, fileType='NIFTI')
#test.brain.fit<- brainMixtureFit2(scans, fit.control = generateMixtureControl())
#x11()
#createSliceGraphic(test.brain.fit[["p3.1"]], z=26)
#image(test.brain.fit[["p3.1"]]$getData()[,,26])
##save(test.brain.fit, file="/home/johnros/workspace/Mixture Random Effects/tmp/VinkDataFit.Rdata")
##load(file="/home/johnros/workspace/Mixture Random Effects/tmp/VinkData.Rdata")
#lapply(test.brain.fit, function(x) x$getData()[20,20,20])









