# TODO: C) Create import function for DICOM format.

# Author: Jonathan Rosenblatt john.ros@gmail.com
###############################################################################
##' Fit mixture models to fMRI group studies.
##' 
##' \tabular{ll}{
##' Package: \tab rosenblatt1\cr
##' Type: \tab Package\cr
##' Version: \tab 0.5\cr
##' Date: \tab 2012-08-19\cr
##' License: \tab GPL (>= 2)\cr
##' }
##' 
##' Mixture model fitting for random effect in fMRI group studies.
##'
##' @name rosenblatt1-package
##' @aliases rosenblatt1
##' @docType package
##' @title Fit mixture models to fMRI group studies
##' @include tractor.base
##' @include mixtools
##' @author Jonathan Rosenblatt 
#NA






#
##' Function imoprting a directory with scans in all formats except DICOM:
##' 
##' @param files A list of file names with full path. 
##' @param ... Arguments passed to \code{\link{newMriImageFromFile}}
##' @return A list containin an \code{\link{MriImage}} class object for each file in the input.
##' 
##' The function is a convinience wrapper around \code{\link{newMriImageFromFile}}. It recieves a list of medical imaging files (in the formats supported by \code{\link{newMriImageFromFile}}) and return a list of \code{\link{MriImage}} objects-- one for each file supplied.
##' 
##' @author Jonathan Rosenblatt 
##' @examples 
##' files<- grep("con.*img", list.files(), value=T)
##' files<- sub('\\.img', "", files)
##' scans<- importBetaMriImages(files, fileType='NIFTI')
##' class(scans[[1]])
##' @export
importBetaMriImages<- function(files, ...){
	# Verify input:
	#~~~
	
	
	# Import:
	require(tractor.base)
	subject.arrays<- list()
	.test.dimentions<- newMriImageFromFile(fileName =files[1], ...)$getDimensions()
	for(i in seq_along(files)){
		subject.arrays[[i]]<- newMriImageFromFile(files[i], ...)
		# Test all scans have the same dimensions:
		if(any(.test.dimentions!= subject.arrays[[i]]$getDimensions())) { stop('Arrays with different resolutions')}
	}
	
	return(subject.arrays)
	
	
}
## examples:
#setwd('~/Projects/MRI/Data/Vink/data_vink_2010/cons_no_smooth')
#(files<- grep("con.*img", list.files(), value=T))
#(files<- sub('\\.img', "", files))
#scans<- importBetaMriImages(files, fileType='NIFTI')
#class(scans[[1]])=="MriImage"
#save(scans, file= '/home/johnros/workspace/Mixture Random Effects/truck/rosenblatt1/data/VinkData.Rdata')























#
##' Generates a list of control arguments.
##' @param numericThresh Numeric value.  
##' @param minObservations Minimal number of observation to attempt fitting.
##' @return List with control parameters for \code{\link{brainMixtureFit}}
##' 
##' @author Jonathan Rosenblatt 
##' @export
generateMixtureControl<- function(
		numericThresh= -18, 
		minObservations= 15, # minimum number of observations for estimation
		iteration.limit=100,
		null.iteration.limit=1000,
		roundTolerance= 15,
		RandomStarts= 5,
		Resolution= 10,
		mStep.iteration.limit=5,
		variance.bound=10,
		iterationTolerance=1e-4
){	
	return(list(
					numericThresh= numericThresh, 	
					minObservations= minObservations,
					iteration.limit=iteration.limit,
					null.iteration.limit=null.iteration.limit,
					roundTolerance=roundTolerance,
					RandomStarts=RandomStarts,
					Resolution=Resolution,
					mStep.iteration.limit=mStep.iteration.limit,
					variance.bound=variance.bound,
					iterationTolerance=iterationTolerance
			))	
}

	
	












#
##' Map mixtools output to simple vector
##' @param mixedtools.output Output of \code{\link{normalmixEM}}. List of class \emph{mixEM}.  
##' @param result The vector to be returned with \code{\link{normalmixEM}} output
##' @param model Character vector specifying the type of model fitted with \code{\link{normalmixEM}}. 
##' @return Vector of voxel-wise parameter estimates.
##' Utility function for \code{\link{pointWiseMixtureFit}}
##' @author Jonathan Rosenblatt 
##' @export
mixedtools2result<- function(mixedtools.output, result, model){
	
	# Preparing output for **full** model:
	if(model=="full"){
		component.order<- c( order(mixedtools.output$sigma[c(1,2)]) , 3)
		result[c("p1.1","p2.1","p3.1")] <- mixedtools.output$lambda[component.order] 
		result[c("A.1","B.1","C.1")] <- mixedtools.output$sigma[component.order]^2
		result["mu.1"]<- mixedtools.output$mu[component.order][3]				
	}
	
	
	
	# Preparing output for **null** model:
	if(model=="null"){
		component.order<- order(mixedtools.output$sigma[c(1,2)]) 
		result[c("p1.0","p2.0")] <- mixedtools.output$lambda[component.order] 
		result[c("A.0","B.0")] <- mixedtools.output$sigma[component.order]^2	
	}
		
	return(result)
}















#
##' Pointwise fitting of group mixture
##' @param beta.vector Numeric vector of estimated contrasts. One per subject.
##' @param fit.control List of control parameters generated by \code{\link{generateMixtureControl}} 
##' @param progress A connection object to a progress bar. 
##' @return Numeric vector with estimates of mixture parameters.
##' 
##' @author Jonathan Rosenblatt 
##' @export
pointWiseMixtureFit<- function(beta.vector, fit.control, progress){
	require(mixtools)
	# Verify intput:
	stopifnot(is.numeric(beta.vector))
	
	
	# Initialize output:
	if(!missing(progress)) { setTxtProgressBar(progress, getTxtProgressBar(progress)+1)	}
	
	output<- initializeOutput()
	n<- sum(!is.na(beta.vector))
	output[['n']]<- n
	if(n < fit.control$minObservations) return(output)
	clean.beta.vector<- na.omit(beta.vector)
	
	
	
	try({
				capture.output(temp.result.three.components <- pointWise3MixtureFit(clean.beta.vector, fit.control))
				output<- mixedtools2result(temp.result.three.components, output, model="full")
				
								
				p3.bound<- p3Bound(mu=output[['mu.1']], A=output[['A.1']], B=output[['B.1']], n=output[['n']], fit.control=fit.control)
				output[['p3.bound']]<- p3.bound
				
				if(output[['p3.1']] > p3.bound) {
					# Note: present implementation forces constraint. Next- optimize with it.
					# TODO: B) Imlpement constrained optimization
					output[['p3.1']]<- p3.bound
				} 
				
				
				
				
				# Fit 2 component mixture
				capture.output(temp.result.two.components<- pointWise2MixtureFit(clean.beta.vector, fit.control, temp.result.three.components))
				output<- mixedtools2result(temp.result.two.components, output, model="null")
				
			}) # End of "try" statement
	
	
	
	
	# Finiliazing:
	return(output)
}
## Testing:
#.data<- scans[30,20,30,]
#(output<- pointWiseMixtureFit(.data, fit.control = generateMixtureControl()))











#
##' Voxelwise fit of *three* component mixture
##' @param beta.vector Nuemric (cleaned) vector of beta estimates.
##' @param fit.control 
##' @return An \link{mixEM} class object of the three component mixture fit.
##' 
##' @author Jonathan Rosenblatt 
##' @examples 
##'.data<- na.omit(scans[20,20,20,])
##'(output.3<- pointWise3MixtureFit(.data, fit.control= generateMixtureControl()))
pointWise3MixtureFit<- function(beta.vector, fit.control){
	
	temp.result<- normalmixEM(beta.vector, k=3, mean.constr = c(0,0,NA), verb=FALSE )
	
	return(temp.result)
	
}
## Testing:
#.data<- na.omit(scans[20,20,20,])
#output.3<- pointWise3MixtureFit(.data, fit.control= generateMixtureControl())
#sum(output.3$lambda)
















##' #' Voxelwise fit of *two* component mixture
##' @param beta.vector Nuemric (cleaned) vector of beta estimates
##' @param fit.control 
##' @param three.component.fit Output of \link{pointWise3MixtureFit} as initialization.
##' @return  An \link{mixEM} class object of the two component mixture fit.
##' 
##' @author Jonathan Rosenblatt 
##' @examples 
##'.data<- na.omit(scans[20,20,20,])
##'output.3<- pointWise3MixtureFit(.data, fit.control= generateMixtureControl())
##'(output.2<- pointWise2MixtureFit(.data, fit.control= generateMixtureControl(), three.component.fit = output.3))
pointWise2MixtureFit<- function(beta.vector, fit.control, three.component.fit){
	renormalize.lambda<- three.component.fit$lambda[c(1,2)] / sum(three.component.fit$lambda[c(1,2)])
	temp.result<- normalmixEM(beta.vector, k=2, mean.constr = c(0,0), verb=FALSE, lambda=renormalize.lambda , mu=c(0,0), sigma=three.component.fit$sigma[c(1,2)] )
	
	return(temp.result)
	
}
## Testing:
#.data<- na.omit(scans[20,20,20,])
#output.3<- pointWise3MixtureFit(.data, fit.control= generateMixtureControl())
#(output.2<- pointWise2MixtureFit(.data, fit.control= generateMixtureControl(), three.component.fit = output.3))























#
##' Generate matrix of neighbouring indexes for brain image imputation
##' 
##' @param i 
##' @param j 
##' @param k 
##' @return Matrix of neighbouring voxel indexes.
##' 
##' @author Jonathan Rosenblatt 
neighbourhoodMatrix<- function(i,j,k){
	as.matrix(expand.grid(
					c(i-1,i,i+1), 
					c(j-1,j,j+1), 
					c(k-1,k,k+1))[-14,])
}
## Testing:
#rosenblatt1:::neighbourhoodMatrix(10,20,30)










# Deprecated by imputeArray2 
imputeArray <- function(beta.array, min.neighbours=20) {
	
	result<- beta.array
	dims<- dim(result)
	
	for(i in 2:(dims[1]-1)){
		for(j in 2:(dims[2]-1)){
			for(k in 2:(dims[3]-1)){
				neighbour.matrix<- neighbourhoodMatrix(i,j,k)
				if( is.na(beta.array[i,j,k]) && sum(!is.na(beta.array[neighbour.matrix])) > min.neighbours ){
					result[i,j,k]<- mean(beta.array[neighbour.matrix], trim=0.1, na.rm=TRUE)					
				}
			}
		}
	}
	
	return(result)
}
## Testing:
#test.array<- array(rnorm(10*10*10), dim=c(10,10,10))
#rosenblatt1:::imputeArray(test.array)






# Impute an array with first degree neighbours (Shlomi's C implementation):
#dyn.load("/home/johnros/workspace/MixtureRandomEffects/trunk/average_NA.so")

imputeArray2 <- function(beta.array, min.neighbours=20) {	
	dims<- dim(beta.array)	
	
		result <- .Call("fill_NA_voxels_with_neig_mean",
				x=as.double(beta.array),
				dim.x=as.integer(dims[1]),
				dim.y=as.integer(dims[2]),
				dim.z=as.integer(dims[3]))
		
		return (array(data=result,dim=dims))
}
## Testing:
#test.array<- array(rnorm(10*10*10), dim=c(10,10,10))
#imputeArray2(test.array)




















#
##' Impute a selected parameters in a brain array
##' @param brain.mixture.fit.object 
##' @param param.to.impute 
##' @return An array of parameter estimates imputed using first degree neighbourhood.
##' 
##' @author Jonathan Rosenblatt 
wrapImputeArray<- function(brain.mixture.fit.object){
	## Initializing:
	dims<- dim(brain.mixture.fit.object)
	dim.names<- dimnames(brain.mixture.fit.object)		
	result<- array(NA, dim=dims, dimnames = dim.names)
	
	
	for (param in dim.names[[1]]){
		result[param,,,]<- imputeArray2(brain.mixture.fit.object[param,,,])
			}
			
	return(result)
	
}
## Testing:
#my.array<- array(rnorm(10^4), dim=c(x=10,y=10,z=10,j=10), dimnames = list(LETTERS[1:10], NULL, NULL, NULL ))
#dimnames(my.array)
#wrapImputeArray(my.array)












#
##' Checks if constraint on p3 is met?
##' @param p1 
##' @param mu 
##' @param A 
##' @param B 
##' @param n 
##' @param fit.control 
##' @return The maximal allowed value for \eqn{p_3}.
##' 
##' @author Jonathan Rosenblatt 
p3Bound<-function(mu, A, B, n, fit.control){
	result<- 1
	expo<- fit.control$numericThresh
	try(expo<- -abs(mu) * sqrt(n / (A + B)), silent=TRUE)
	if(!is.na(expo)) result<- 1 - exp(expo)			
	return(result)
}
## Test:
#p3Bound(3,1,2,67, generateMixtureControl())











#
##' Converts a list of MRIimage objects to a single four dimentional array.
##' @param MRImage.list List of Mriimage objects. All assumed to have same resolutino and representing different subjects.
##' @return A numeric four dimentional array with space as first three dimentions and subject as the fourth.
##' 
##' @author Jonathan Rosenblatt 
##' @export
##' @examples
##' data(VinkData)
##' MriImage2Array(scans)

MriImage2Array<- function(MRImage.list){
	
	
	## Initialize: 
	single.scan.dim<- MRImage.list[[1]]$getDimensions()
	number.of.sbjects<- length(MRImage.list)
	dims<-c(single.scan.dim, number.of.sbjects)
	
	
	beta.array<- array(0, dim=dims, dimnames = c('x','y','z', 'subjects'))
	for(i in seq_along(MRImage.list)){
		beta.array[, , , i]<- MRImage.list[[i]]$getData()		
	}
	
	# Finalize:
	return(beta.array)
	
}
## Testing:
#setwd('~/Projects/MRI/Data/Vink/data_vink_2010/cons_no_smooth')
#(files<- grep("con.*img", list.files(), value=T))
#(files<- sub('\\.img', "", files))
#scans<- importBetaMriImages(files, fileType='NIFTI')
#MriImage2Array(scans)





















##' Fits a mixture models to a group SPM{beta}
##' @param MRImage.list  List of Mriimage objects. All assumed to have same resolution and representing different subjects.
##' @param fit.control List of control parameters generated by \code{\link{generateMixtureControl}} 
##' @param ... Deprecated
##' @return List of MriImage objects. Each holding the SPM of a different parameters:
##' \item{initial.p1}{Deprecated}
##' \item{initial.p2}{Deprecated}
##' \item{initial.p3}{Deprecated}
##' \item{initial.mu}{Deprecated}
##' \item{initial.A}{Deprecated}
##' \item{initial.B}{Deprecated}
##' \item{initial.C}{Deprecated}
##' \item{p1.1}{Estimate of \emph{full} mixture parameters.}
##' \item{p2.1}{Estimate of \emph{full} mixture parameters.}
##' \item{p3.1}{Estimate of \emph{full} mixture parameters.}
##' \item{mu.1}{Estimate of \emph{full} mixture parameters.}
##' \item{A.1}{Estimate of \emph{full} mixture parameters.}
##' \item{B.1}{Estimate of \emph{full} mixture parameters.}
##' \item{C.1}{Estimate of \emph{full} mixture parameters.}
##' \item{likelihood.1}{\emph{Full} maximal likelihood.}
##' \item{p3.bound}{Maximal allowed value for p.3 given other parameter estimates. Serves to check if parameter space constraints are violated.}
##' \item{p1.0}{Estimate of \emph{null} mixture parameters.}
##' \item{p2.0}{Estimate of \emph{null} mixture parameters.}
##' \item{A.0}{Estimate of \emph{null} mixture parameters.}
##' \item{B.0}{Estimate of \emph{null} mixture parameters.}
##' \item{likelihood.0}{\emph{Null} maximal likelihood}
##' \item{n}{Sample size.}
##'     
##' Given a list of MriImage objects-- all registered to a common template--   the function will fit a mixture model at each voxel and return an array of the voxel-wise parameter estimates.
##' The fitting is done using the \link{mixtools}  package.
##' The mixture being fitted is parametrized as: \deqn{p_1 \phi_{0,\sigma_1}+p_2 \phi_{0,\sigma_2}+p_3 \phi_{\mu,\sigma_3}   } where
##' \eqn{\phi_{\mu,\sigma}} is the Gaussian PDF.
##'  
##' @author Jonathan Rosenblatt 
##' @references Revisiting Multi-Subject Random Effects in fMRI
##' Rosenblatt J.D., Vink M., Benjamini Y. (2012) 
##' @examples 
##' data(VinkData)
##' ### No need to run. Output already in VinkDataFit in order to save time.
##' #test.brain.fit<- brainMixtureFit(scans, fit.control = generateMixtureControl())
##' data(VinkDataFit)
##' createSliceGraphic(test.brain.fit[["p3.1"]], z=26)
##' image(test.brain.fit[["p3.1"]]$getData()[,,26])
##' lapply(test.brain.fit, function(x) x$getData()[20,20,20])
##' @export
brainMixtureFit2<- function(MRImage.list, fit.control= generateMixtureControl()){
	
	## Verify input:
	stopifnot(is.list(MRImage.list) && class(MRImage.list[[1]])=="MriImage" ) 
	
	
		
	## Initialize:
	#Arranging data in one array:
	beta.array<- MriImage2Array(MRImage.list)
	
	# For debugging:	beta.array<- beta.array[25:30,28:30,28:30,]
	
	dims<-dim(beta.array)
	cat('This may take several minutes. Why not load the fortunes package and enjoy those quotes?\n')
	log.file.name<- tempfile("Mixture_Log_")
	log.con<- file(log.file.name, open="wt")
	sink(file=log.con, type="message")
	cat("Log written to", log.file.name,"\n")	
	progress.bar<- txtProgressBar(min=0, max=prod(dims[-4]), style=1)
	warn <- options(warn = 2)
	
	
	
	
	
	
	## Fit- first step
	pointwise<- function(beta.vector) {
		unlist(pointWiseMixtureFit(beta.vector = beta.vector, fit.control = fit.control, progress=progress.bar))
	}
	
	
	first.fit <- apply(beta.array, c(1,2,3), pointwise)
	close(progress.bar)
	
		
	
	
	
	# TODO: C) Add imputation and smoothing before re-estimation + check which solution has highest likelihood
	
	## Smooth estimates:
	# impute array before smoothing
	# smooth estimates	
	smoothed.fit<- first.fit	
	
	
	
	## Second fit:
	second.fit<- smoothed.fit
	
	
	
	
	## Impute non-convergence
	imputed.fit<-  wrapImputeArray(second.fit)
	
	


	## Finilizing
	dim.names<- dimnames(first.fit)
	fitted.list<- list()
	meta<- newMriImageMetadataFromTemplate(MRImage.list[[1]]$getMetadata(), datatype=getDataTypeByNiftiCode(16))
	for(param in dim.names[[1]]){
		fitted.list[[param]]<- newMriImageWithData(imputed.fit[param,,,], meta)
	}
	
	
	
	## Exit:
	options(warn)
	sink(type="message")
	message('Done')
	return(fitted.list)
	
	
}
## Testing:
#require(tractor.base)
#setwd('~/Projects/MRI/Data/Vink/data_vink_2010/cons_no_smooth')
#(files<- grep("con.*img", list.files(), value=T))
#(files<- sub('\\.img', "", files))
#scans<- importBetaMriImages(files, fileType='NIFTI')
#test.brain.fit<- brainMixtureFit2(scans, fit.control = generateMixtureControl())
#x11()
#createSliceGraphic(test.brain.fit[["p3.1"]], z=26)
#image(test.brain.fit[["p3.1"]]$getData()[,,26])
##save(test.brain.fit, file="/home/johnros/workspace/Mixture Random Effects/tmp/VinkDataFit.Rdata")
##load(file="/home/johnros/workspace/Mixture Random Effects/tmp/VinkData.Rdata")
#lapply(test.brain.fit, function(x) x$getData()[20,20,20])

















#
##' Export all estimated parameters to imaging files
##' @param mixture.fit.object Output of \code{\link{brainMixtureFit}}
##' @param format The medical imaging format to export. See details.
##' @param file.heading Heading of output files.
##' @return Nothing. Called for it's side effects.
##' 
##' This is a convenience wrapper around \code{\link{writeMriImageToFile}}.
##'  
##' It exports all the SPM outputed by \code{\link{brainMixtureFit}} and saves them in any of the formats supported by \code{\link{writeMriImageToFile}. 
##' @author Jonathan Rosenblatt 
##' @export
##' @examples
##' #exportFitAsMedicalImage(mixture.fit.object = test.brain.fit, file.heading = "export", format = "test")
exportFitAsMedicalImage<- function(mixture.fit.object, format, file.heading){
	## Verify input:
	stopifnot(is.character(file.heading))
	stopifnot(is.character(format))
	stopifnot(all(sapply(mixture.fit.object, class)=="MriImage"))
	
	
	## Initialize:
	require(tractor.base)
	
	
	params<- names(mixture.fit.object)	
	for(param in params){
		file.name<- paste(file.heading, "_", param, sep="")
		writeMriImageToFile(mixture.fit.object[[param]], fileName = file.name, fileType=format, overwrite = FALSE)
	}
		
	## Finalize:
	cat("Files save in ", getwd())
}
## Testing:
#setwd("/home/johnros/workspace/Mixture Random Effects/tmp/")
#exportFitAsMedicalImage(mixture.fit.object = test.brain.fit, file.heading = "export", format = "dfsdfs")















#
##' Computes a rejecton group mask given beta maps.
##' @param MRImage.list List of Mriimage objects. All assumed to have same resolutino and representing different subjects.
##' @param test.statistic Which group test statistic to use. At present "T" or "Wilcoxon" (default) are supported.
##' @param FDR.level Level of FDR multiplicity control. 
##' @param fit.control List of control parameters generated by \code{\link{generateMixtureControl}} 
##' @return An \link{MriImage} class object corresponding to the binary mask of rejected locations.
##' 
##' @author Jonathan Rosenblatt 
##' @export
##' @examples
##' data(VinkDataFit) 
##' test.brain.mask<- computeMask(MRImage.list=scans, method = "T", fit.control = generateMixtureControl())
##' createSliceGraphic(test.brain.mask, z=30)

computeMask<- function(MRImage.list, test.statistic="Wilcoxon", FDR.level=0.1, fit.control=generateMixtureControl()){
	## Verify input:
	stopifnot(is.list(MRImage.list) && class(MRImage.list[[1]])=="MriImage" ) 
	stopifnot(is.numeric(FDR.level) && FDR.level<1 && FDR.level>0)
	
	
	
	## Initialize:
	beta.array<- MriImage2Array(MRImage.list)
	dims<- dim(beta.array)	
	min.n<- fit.control$minObservations
	
	
	
	# Create map of p-values according to the method
	if(test.statistic=="T"){
		pvals.array<- apply(beta.array, c(1,2,3), function(x){
					result<- NA
					if(sum(is.finite(x)) < min.n) return(result)
					try(result <- t.test(x)[['p.value']] )
					return(result)
				}	) 
	}
	
	
	
	else if(test.statistic=="Wilcoxon"){
		pvals.array<- apply(beta.array, c(1,2,3), function(x){
					result<- NA
					if(sum(is.finite(x)) < min.n) return(result)
					try(result<- wilcox.test(x, mu=0, alternative="two.sided", exact=FALSE)$p.value)
					return(result)
				}	)
	}
	
		
	else{
		message("The method supplied is not valid.")
	}
	
	
	
	## Compute FDR adjusted p-values
	output<- array(p.adjust(pvals.array, method = 'BH')<= FDR.level, dim=dims[1:3])
	
	
	
	
	
	## Finialize:
	meta<- newMriImageMetadataFromTemplate(MRImage.list[[1]]$getMetadata(), datatype=getDataTypeByNiftiCode(2))
	mri.mask<- newMriImageWithData(output, meta)
	return(mri.mask)
	
	
}
## Testing:
#require(tractor.base)
#setwd('~/Projects/MRI/Data/Vink/data_vink_2010/cons_no_smooth')
#files<- grep("con.*img", list.files(), value=T)
#files<- sub('\\.img', "", files)
#scans<- importBetaMriImages(files, fileType='NIFTI')
#test.brain.mask<- computeMask(MRImage.list=scans, method = "T", fit.control = generateMixtureControl())
#createSliceGraphic(test.brain.mask, z=30)


























