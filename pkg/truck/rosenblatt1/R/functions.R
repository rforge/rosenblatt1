## TODO: B) Create import function for DICOM format.

# Author: Jonathan Rosenblatt john.ros@gmail.com
###############################################################################








#' Function imoprting a directory with scans in all formats except DICOM:
#' 
#' @param files A list of file names with full path. 
#' @param ... Arguments passed to \code{\link{newMriImageFromFile}}
#' @returnType MriImage
#' @return A list containin an \code{\link{MriImage}} class object for each file in the input.
#' @details The function is a convinience wrapper around \code{\link{newMriImageFromFile}}. It recieves a list of medical imaging files (in the formats supported by \code{\link{newMriImageFromFile}}) and return a list of \code{\link{MriImage}} objects-- one for each file supplied.
#' @author johnros
#' @export
#' @example 
#' \dontrun{#' 
#' files<- grep("con.*img", list.files(), value=T)
#' files<- sub('\\.img', "", files)
#' scans<- importBetaMriImages(files, fileType='NIFTI')
#' class(scans[[1]])
#' }
importBetaMriImages<- function(files, ...){
	# Verify input:
	#~~~
	
	
	# Import:
	require(tractor.base)
	subject.arrays<- list()
	.test.dimentions<- newMriImageFromFile(fileName =files[1], ...)$getDimensions()
	for(i in seq_along(files)){
		subject.arrays[[i]]<- newMriImageFromFile(files[i], ...)
		# Test all scans have the same dimensions:
		if(any(.test.dimentions!= subject.arrays[[i]]$getDimensions())) { error('Arrays with different resolutions')}
	}
	
	return(subject.arrays)
	
	
}
## Example:
#setwd('~/Projects/MRI/Data/Vink/data_vink_2010/cons_no_smooth')
#(files<- grep("con.*img", list.files(), value=T))
#(files<- sub('\\.img', "", files))
#scans<- importBetaMriImages(files, fileType='NIFTI')
#class(scans[[1]])=="MriImage"
























#' Generates a list of control arguments.
#' @param numericThresh Numeric value.  
#' @param minObservations Minimal number of observation to attempt fitting.
#' @returnType list
#' @return List with control parameters for \code{\link{brainMixtureFit}}
#' 
#' @author johnros
#' @export
generateMixtureControl<- function(
		numericThresh= -18, 
		minObservations= 15 # minimum number of observations for estimation
){	
	return(list(
					numericThresh= numericThresh, 	
					minObservations= minObservations
			))	
}

	
	













#' Map mixtools output to simple vector
#' @param mixedtools.output Output of \code{\link{normalmixEM}}. List of class \emph{mixEM}.  
#' @param result The vector to be returned with \code{\link{normalmixEM}} output
#' @param model Character vector specifying the type of model fitted with \code{\link{normalmixEM}}. 
#' @returnType numeric
#' @return 
#' Utility function for \code{\link{pointWiseMixtureFit}}
#' @author johnros
#' @export
mixedtools2result<- function(mixedtools.output, result, model){
	
	# Preparing output for **full** model:
	if(model=="full"){
		component.order<- c( order(mixedtools.output$sigma[c(1,2)]) , 3)
		result[c("p1.1","p2.1","p3.1")] <- mixedtools.output$lambda[component.order] 
		result[c("A.1","B.1","C.1")] <- mixedtools.output$sigma[component.order]^2
		result["mu.1"]<- mixedtools.output$mu[component.order][3]				
	}
	
	
	
	# Preparing output for **full** model:
	if(model=="null"){
		component.order<- order(mixedtools.output$sigma[c(1,2)]) 
		result[c("p1.0","p2.0")] <- mixedtools.output$lambda[component.order] 
		result[c("A.0","B.0")] <- mixedtools.output$sigma[component.order]^2	
	}
		
	# Preparing output for **full** model:
	return(result)
}
















#' Pointwise fitting of group mixture
#' @param beta.vector Numeric vector of estimated contrasts. One per subject.
#' @param fit.control List of control parameters generated by \link{\code{generateMixtureControl}} 
#' @param progress A connection object to a progress bar. 
#' @returnType numeric 
#' @return Numeric vector with estimates of mixture parameters.
#' 
#' @author johnros
#' @export
pointWiseMixtureFit<- function(beta.vector, fit.control, progress){
	# Verify intput:
	stopifnot(is.numeric(beta.vector))
	
	
	# Initialize output:
	if(!missing(progress)) { setTxtProgressBar(progress, getTxtProgressBar(progress)+1)	}
	
	output.names<-c(
			"initial.p1", "initial.p2", "initial.p3", "initial.mu", "initial.A", "initial.B", "initial.C",
			"p1.1", "p2.1", "p3.1",
			"mu.1",
			"A.1", "B.1", "C.1", 
			"likelihood.1",
			"p3.bound",
			"p1.0","p2.0",
			"A.0","B.0",
			"likelihood.0",
			"n"
	)
	output<- rep(NA, length.out= length(output.names))
	names(output)<- output.names
	n<- sum(!is.na(beta.vector))
	output[['n']]<- n
	if(n < fit.control$minObservations) return(output)
	clean.beta.vector<- na.omit(beta.vector)
	
	
	
	## TODO: B) Add initialization tricks.
	
	# Fit 3 component mixture
	try({
				capture.output(temp.result.three.components <- pointWise3MixtureFit(clean.beta.vector, fit.control))
				output<- mixedtools2result(temp.result.three.components, output, model="full")
				
								
				p3.bound<- p3Bound(p1=output[['p1.1']], mu=output[['mu.1']], A=output[['A.1']], B=output[['B.1']], n=output[['n']], fit.control=fit.control)
				output[['p3.bound']]<- p3.bound
				
				if(output[['p3.1']] > p3.bound) {
					# Note: present implementation forces constraint. Next- optimize with it.
					# TODO: B) Imlpement constrained optimization
					output[['p3.1']]<- p3.bound
				} 
				
				
				
				
				# Fit 2 component mixture
				capture.output(temp.result.two.components<- pointWise2MixtureFit(clean.beta.vector, fit.control, temp.result.three.components))
				output<- mixedtools2result(temp.result.two.components, output, model="null")
				
			}) # End of "try" statement
	
	
	
	
	# Finiliazing:
	return(output)
}
## Testing:
#.data<- scans[30,20,30,]
#(output<- pointWiseMixtureFit(.data, fit.control = generateMixtureControl()))












# Function for pointwise fitting **full** model:
pointWise3MixtureFit<- function(beta.vector, fit.control){
	
	temp.result<- normalmixEM(beta.vector, k=3, mean.constr = c(0,0,NA), verb=FALSE )
	
	return(temp.result)
	
}
## Testing:
#.data<- na.omit(scans[20,20,20,])
#output.3<- pointWise3MixtureFit(.data, fit.control= generateMixtureControl())
#sum(output.3$lambda)















# Function for pointwise fitting null model:
pointWise2MixtureFit<- function(beta.vector, fit.control, three.component.fit){
	renormalize.lambda<- three.component.fit$lambda[c(1,2)] / sum(three.component.fit$lambda[c(1,2)])
	temp.result<- normalmixEM(beta.vector, k=2, mean.constr = c(0,0), verb=FALSE, lambda=renormalize.lambda , mu=c(0,0), sigma=three.component.fit$sigma[c(1,2)] )
	
	return(temp.result)
	
}
## Testing:
#.data<- na.omit(scans[20,20,20,])
#output.3<- pointWise3MixtureFit(.data, fit.control= generateMixtureControl())
#(output.2<- pointWise2MixtureFit(.data, fit.control= generateMixtureControl(), three.component.fit = output.3))
























# Generate matrix of neighbouring indexes
neighbourhoodMatrix<- function(i,j,k){
	as.matrix(expand.grid(c(i-1,i,i+1), c(j-1,j,j+1), c(k-1,k,k+1))[-14,])
}










#' Impute an array with first degree neighbours
#' @param beta.array 
#' @param min.neighbours 
#' @returnType 
#' @return 
#' 
#' @author johnros
#' @export
imputeArray <- function(beta.array, min.neighbours=20) {
	
	## TODO: A) speedup imputation.
	result<- beta.array
	dims<- dim(result)
	
	for(i in 2:(dims[1]-1)){
		for(j in 2:(dims[2]-1)){
			for(k in 2:(dims[3]-1)){
				neighbour.matrix<- neighbourhoodMatrix(i,j,k)
				if( is.na(beta.array[i,j,k]) && sum(!is.na(beta.array[neighbour.matrix])) > min.neighbours ){
					result[i,j,k]<- mean(beta.array[neighbour.matrix], trim=0.1, na.rm=TRUE)
					
				}
			}
		}
	}
	
	return(result)
}












#' Impute a selected parameters in a brain array
#' @param brain.mixture.fit.object 
#' @param param.to.impute 
#' @returnType 
#' @return 
#' 
#' @author johnros
#' @export
wrapImputeArray<- function(brain.mixture.fit.object){
	## Initializing:
	dims<- dim(brain.mixture.fit.object)
	dim.names<- dimnames(brain.mixture.fit.object)		
	result<- array(NA, dim=dims, dimnames = dim.names)
	
	
	for (param in dim.names[[1]]){
		result[param,,,]<- imputeArray(brain.mixture.fit.object[param,,,])
			}
			
	return(result)
	
}
## Testing:
#my.array<- array(rnorm(10^4), dim=c(x=10,y=10,z=10,j=10), dimnames = list(NULL, NULL, NULL, LETTERS[1:10]))
#dimnames(my.array)
#wrapImputeArray(my.array)













#' Checks if constraint on p3 is met?
#' @param p1 
#' @param mu 
#' @param A 
#' @param B 
#' @param n 
#' @param fit.control 
#' @returnType 
#' @return 
#' 
#' @author johnros
p3Bound<-function(p1, mu, A, B, n, fit.control){
	result<- 1
	stopifnot(is.numeric(c(p1,A, B, mu)))
	expo<- fit.control$numericThresh
	try(expo<- -abs(mu) * sqrt(n / (A + B)), silent=TRUE)
	if(!is.na(expo)) result<- 1 - exp(expo)			
	return(result)
}
## Test:
#p3.bound(0.2,0.5,3,1,2,67,EM9.control)











#' Converts a list of MRIimage objects to a single four dimentional array.
#' @param MRImage.list List of Mriimage objects. All assumed to have same resolutino and representing different subjects.
#' @returnType array
#' @return A numeric four dimentional array with space as first three dimentions and subject as the fourth.
#' 
#' @author johnros
#' @export
MriImage2Array<- function(MRImage.list){
	
	
	## Initialize: 
	single.scan.dim<- MRImage.list[[1]]$getDimensions()
	number.of.sbjects<- length(MRImage.list)
	dims<-c(single.scan.dim, number.of.sbjects)
	
	
	beta.array<- array(0, dim=dims, dimnames = c('x','y','z', 'subjects'))
	for(i in seq_along(MRImage.list)){
		beta.array[, , , i]<- MRImage.list[[i]]$getData()		
	}
	
	# Finalize:
	return(beta.array)
	
}
## Testing:
#setwd('~/Projects/MRI/Data/Vink/data_vink_2010/cons_no_smooth')
#(files<- grep("con.*img", list.files(), value=T))
#(files<- sub('\\.img', "", files))
#scans<- importBetaMriImages(files, fileType='NIFTI')
#MriImage2Array(scans)






















#' Fits a full and null mixture models to a SPM{beta}
#' @param MRImage.list  List of Mriimage objects. All assumed to have same resolutino and representing different subjects.
#' @param fit.control List of control parameters generated by \link{\code{generateMixtureControl}} 
#' @param ... 
#' @returnType list
#' @return List of MriImage objects. Each holding the SPM of a different parameters:
#' \item{initial.p1}{}
#' \item{initial.p2}{}
#' \item{initial.p3}{}
#' \item{initial.mu}{}
#' \item{initial.A}{}
#' \item{initial.B}{}
#' \item{initial.C}{}
#' \item{p1.1}{}
#' \item{p2.1}{}
#' \item{p3.1}{}
#' \item{mu.1}{}
#' \item{A.1}{}
#' \item{B.1}{}
#' \item{C.1}{}
#' \item{likelihood.1}{}
#' \item{p3.bound}{}
#' \item{p1.0}{}
#' \item{p2.0}{}
#' \item{A.0}{}
#' \item{B.0}{}
#' \item{likelihood.0}{}
#' \item{n}{}
#'     
#' @details 
#' @author johnros
#' @references Revisiting Multi-Subject Random Effects in fMRI
#' Rosenblatt J.D., Vink M., Benjamini Y. (2012) 
#' @export
brainMixtureFit<- function(MRImage.list, fit.control= generateMixtureControl(), ...){
	## TODO: B) Finish mixture fitting function.
	
	## Verify input:
	stopifnot(is.list(MRImage.list) && class(MRImage.list[[1]])=="MriImage" ) 
	
	
		
	## Initialize:
	#Arranging data in one array:
	beta.array<- MriImage2Array(MRImage.list)
	
	# For debugging:	beta.array<- beta.array[25:30,28:30,28:30,]
	
	dims<-dim(beta.array)
	cat('This may take several minutes. Why not load the fortunes package and enjoy those quotes?\n')
	log.file.name<- tempfile("Mixture_Log_")
	log.con<- file(log.file.name, open="wt")
	sink(file=log.con, type="message")
	cat("Log written to", log.file.name,"\n")	
	progress.bar<- txtProgressBar(min=0, max=prod(dims[-4]), style=1)
	warn <- options(warn = 2)
	
	
	
	
	
	
	## Fit- first step
	pointwise<- function(beta.vector) {
		unlist(pointWiseMixtureFit(beta.vector = beta.vector, fit.control = fit.control, progress=progress.bar))
	}
	
	
	first.fit <- apply(beta.array, c(1,2,3), pointwise)
	close(progress.bar)
	
		
	
	
	
	## TODO: B) Add imputation and smoothing before re-estimation + check which solution has highest likelihood
	
	## Smooth estimates:
	# impute array before smoothing
	# smooth estimates	
	smoothed.fit<- first.fit	
	
	
	
	## Second fit:
	second.fit<- smoothed.fit
	
	
	
	
	## Impute non-convergence
	imputed.fit<-  wrapImputeArray(second.fit)
	
	


	## Finilizing
	dim.names<- dimnames(first.fit)
	fitted.list<- list()
	meta<- newMriImageMetadataFromTemplate(MRImage.list[[1]]$getMetadata(), datatype=getDataTypeByNiftiCode(16))
	for(param in dim.names[[1]]){
		fitted.list[[param]]<- newMriImageWithData(imputed.fit[param,,,], meta)
	}
	
	
	
	## Exit:
	options(warn)
	sink(type="message")
	message('Done')
	return(fitted.list)
	
	
}
## Testing:
#require(tractor.base)
#setwd('~/Projects/MRI/Data/Vink/data_vink_2010/cons_no_smooth')
#(files<- grep("con.*img", list.files(), value=T))
#(files<- sub('\\.img', "", files))
#scans<- importBetaMriImages(files, fileType='NIFTI')
#test.brain.fit<- brainMixtureFit(scans, fit.control = generateMixtureControl())
#x11()
#createSliceGraphic(test.brain.fit[["p3.1"]], z=26)
#image(test.brain.fit[["p3.1"]]$getData()[,,26])
##save(test.brain.fit, file="/home/johnros/workspace/Mixture Random Effects/tmp/VinkData.Rdata")
##load(file="/home/johnros/workspace/Mixture Random Effects/tmp/VinkData.Rdata")
#lapply(test.brain.fit, function(x) x$getData()[20,20,20])


















#' Export all estimated parameters to imaging files
#' @param mixture.fit.object The list output of \code{\link{brainMixtureFit}}
#' @param format The medical imaging format to export. See details.
#' @param file.heading 
#' @returnType 
#' @return 
#' @details This is a convenience wrapper around \code{\link{writeMriImageToFile}}. It exports all the SPM outputed by \code{\link{brainMixtureFit}} and saves them in any of the formats supported by \code{\link{writeMriImageToFile}. 
#' @author johnros
#' @export
exportArrayAsMedicalImage<- function(mixture.fit.object, format, file.heading){
	## Verify input:
	stopifnot(is.character(file.heading))
	stopifnot(is.character(format))	
	stopifnot(all(sapply(mixture.fit.object, class)=="MriImage"))
	
	
	## Initialize:
	require(tractor.base)
	
	
	params<- names(mixture.fit.object)	
	for(param in params){
		file.name<- paste(file.heading, "_", param, sep="")
		writeMriImageToFile(mixture.fit.object[[param]], fileName = file.name, fileType=format)
	}
		
	## Finalize:
	cat("Files save in ", getwd())
}
## Testing:
#setwd("/home/johnros/workspace/Mixture Random Effects/tmp/")
#exportArrayAsMedicalImage(mixture.fit.object = test.brain.fit, file.heading = "export", format = "test")
















#' Computes a rejecton group mask given beta maps.
#' @param MRImage.list List of Mriimage objects. All assumed to have same resolutino and representing different subjects.
#' @param test.statistic Which group test statistic to use. At present "T" or "Wilcoxon" (default) are supported.
#' @param FDR.level Level of FDR multiplicity control. 
#' @param fit.control List of control parameters generated by \link{\code{generateMixtureControl}} 
#' @returnType 
#' @return 
#' 
#' @author johnros
#' @export
computeMask<- function(MRImage.list, test.statistic="Wilcoxon", FDR.level=0.1, fit.control){
	## Verify input:
	stopifnot(is.list(MRImage.list) && class(MRImage.list[[1]])=="MriImage" ) 
	stopifnot(is.numeric(FDR.level) && FDR.level<1 && FDR.level>0)
	
	
	
	## Initialize:
	beta.array<- MriImage2Array(MRImage.list)
	dims<- dim(beta.array)	
	min.n<- fit.control$minObservations
	
	
	
	# Create map of p-values according to the method
	if(test.statistic=="T"){
		pvals.array<- apply(beta.array, c(1,2,3), function(x){
					result<- NA
					if(sum(is.finite(x)) < min.n) return(result)
					try(result <- t.test(x)[['p.value']] )
					return(result)
				}	) 
	}
	
	
	
	else if(test.statistic=="Wilcoxon"){
		pvals.array<- apply(beta.array, c(1,2,3), function(x){
					result<- NA
					if(sum(is.finite(x)) < min.n) return(result)
					try(result<- wilcox.test(x, mu=0, alternative="two.sided", exact=FALSE)$p.value)
					return(result)
				}	)
	}
	
		
	else{
		message("The method supplied is not valid.")
	}
	
	
	
	## Compute FDR adjusted p-values
	output<- array(p.adjust(pvals.array, method = 'BH')<= FDR.level, dim=dims[1:3])
	
	
	
	
	
	## Finialize:
	meta<- newMriImageMetadataFromTemplate(MRImage.list[[1]]$getMetadata(), datatype=getDataTypeByNiftiCode(2))
	mri.mask<- newMriImageWithData(output, meta)
	return(mri.mask)
	
	
}
## Testing:
#require(tractor.base)
#setwd('~/Projects/MRI/Data/Vink/data_vink_2010/cons_no_smooth')
#files<- grep("con.*img", list.files(), value=T)
#files<- sub('\\.img', "", files)
#scans<- importBetaMriImages(files, fileType='NIFTI')
#test.brain.mask<- computeMask(MRImage.list=scans, method = "T", fit.control = generateMixtureControl())
#createSliceGraphic(test.brain.mask, z=30)


























